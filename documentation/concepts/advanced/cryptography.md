
<!-- 
It is constructed from a randomly-sampled **seed**. This seed is used to generate:
- a **secret key** for the account signature scheme
- a **pseudorandom function seed** for transaction serial numbers
- a **commitment randomness** for the account commitment scheme


## Advanced Topics

The descriptions of algorithms below make use of the following definitions of mathematical objects:

### Prime Fields

For a prime `r`, the prime field of order `r` is defined as the set of integers `{0, 1, ..., r - 1}` with addition and multiplication modulo `r`.
In this document, we will use two prime fields:
* <code>F<sub>scalar</sub></code>, of prime order `p = 2111115437357092606062206234695386632838870926408408195193685246394721360383`
* <code>F<sub>base</sub></code>, of prime order `q = 8444461749428370424248824938781546531375899335154063827935233455917409239041`

### Prime Order Elliptic Curve Groups

In this document, we will consider the order-`p` subgroup of points on an elliptic curve defined over the base field <code>F<sub>base</sub></code>.  

Elements of this subgroup consist of a coordinate pair `(x, y)`. The group has two
associated operations: point addition, and point doubling. The group also has a distinguished point, the **generator** `G`,
which is a fixed point of the group.

### HashToField

For a finite field `F`, HashToField is a cryptographic hash function that takes as input either a sequence of bytes or 
a sequence of field elements and outputs a field element. The output is uniformly distributed over the field `F`.

### HashToScalar
An instantiation of HashToField that output elements in the scalar field <code>F<sub>scalar</sub></code>.
[source code](https://github.com/ProvableHQ/snarkVM/blob/mainnet/console/algorithms/src/poseidon/hash_to_scalar.rs)

### EncodeToF

EncodeToF(x) is a function that encodes the Unicode string `x` into an element of <code>F<sub>base</sub></code>.

Details of the encoding:
- `x` is converted to its UTF-8 sequence of bytes `b`.
- `b` is turned into an unsigned integer `v` that represents the little endian value of `b`.
- `v` is reduced modulo the prime that defines the field <code>F<sub>base</sub></code>.

### Account Prefixes

|                         |  Type  | Human-Readable Prefix |                       Prefix Bytes                        |
|:-----------------------:|:------:|:---------------------:|:---------------------------------------------------------:|
| **Account Private Key** | bytes  | `APrivateKey1`        | `[127, 134, 189, 116, 210, 221, 210, 137, 145, 18, 253]`  |
| **Account View Key**    | bytes  | `AViewKey1`           | `[ 14, 138, 223, 204, 247, 224, 122 ]`                    |
| **Account Address**     | string | `aleo1`               | `aleo1`                                                   |

### Offline Accounts

In many instances such as enterprise settings, it is advisable to handle sensitive keys and data on isolated, offline machines.
An Aleo account can be created on an offline machine and available for immediate use. In conjunction with account proving keys,
a user can ensure their private key remains offline even for creating transactions.

While no solution is perfect, it is advisable to create a new Aleo account on a disconnected device to minimize the risk of
leaking one's account private key to unintended parties.

### Account Commitment Outputs

The account commitment output is used to create an account view key, which is comprised of an encryption secret key.
This encryption secret key is a scalar field element derived from the account commitment output. To ensure the validity
of the account view key, the account commitment output should be representable in the scalar field.

### Create an Account

Given global instantiated Aleo parameters and subroutines.

#### Generate a Private Key

1. Sample a 32 byte `seed` from random

2. Construct private key components
    - `sk_sig` = HashToScalar(EncodeToF("AleoAccountSignatureSecretKey0") || `seed`)
    - `r_sig` = HashToScalar(EncodeToF("AleoAccountSignatureRandomizer0.0") || `seed`)

    where || denotes concatenation, and `HashToScalar` denotes the [Poseidon hash function](https://eprint.iacr.org/2019/458.pdf), specifically with an input rate of 2. `seed` is converted into `Field` type before hashing.

3.`private_key` = (`seed`, (`sk_sig`, `r_sig`))

#### Generate a View Key
1. `(sk_sig, r_sig)` = `private_key`
2. `view_key` = `sk_sig` + `r_sig` + HashToScalar(`sk_sig` * `G` || `r_sig` * `G`)

where `G` is the generator of the base field, which is a vector of elliptic curve group elements generated by hashing a given input domain message to a curve point and repeatedly doubling it up to the size of the scalar field (in bits). `+` is scalar addition.

#### Generate an Address

1. `address` = `view_key` * `G` 

-->




<!-- #### Record v0
- Uses the BHP hash to derive the record commitment  
- No sender ciphertext is included  
- Can only be decrypted with an account’s view key
- Allowed before Consensus V8, but disallowed after

#### Record v1
- Uses a BHP commitment with a nonce to derive the record commitment, where the nonce is generated from the record view key
- Enhanced privacy with hiding properties
- Includes encrypted sender ciphertext, allowing users to determine which address sent them a record
- Can be decrypted with the record view key without sharing an account’s view key
- Required after Consensus V8 -->



<!-- For a practical demonstration of a record in Aleo, watch the video [here](https://youtu.be/JIgrKv_Q6Jo?feature=shared) (Version 0). More record details can be found in [transitions](./04_transitions.md#record).  -->
<!-- 
## Diving into the Concepts
To understand how to use records, we must understand the design principles behind Aleo.
Autonomous Ledger Execution Offchain (Aleo) is a layer-1 blockchain that combines general-purpose programmability with privacy by default.
The core idea behind Aleo is ZEXE or zero-knowledge execution initially written in this [research paper](https://eprint.iacr.org/2018/962.pdf) in 2018. It first introduced the record model which extends the UTXO model from Zcash and enables storing and encrypting arbitrary data (user assets and application states), rather than just values of specific assets or tokens.

### Privacy
There are generally four different types of privacy that relate to blockchains.

Aleo fulfils three of them:
- [x] Private inputs (messages)
- [x] Private outputs (state changes)
- [x] Private user
- [ ] Private function

Initially, Aleo was aiming for function privacy as well (as detailed in the original ZEXE paper) but decided against it as it would have led to worse performance and longer proving times.


### Comparing state storage in blockchains
There are two main state models used in blockchains - UTXO (unspent transaction output) and the account model (introduced by Ethereum).

Aleo uses a variation of the UTXO model - the record model.

<p align="center" width="100%">
<img src={require("./images/account_vs_utxo.png").default} alt="Account vs UTXO"></img>
</p>

<p align="center" width="100%">
Source: <a href="https://www.galaxy.com/insights/research/mev-how-flashboys-became-flashbots/">galaxy.com</a>
</p>
<br></br>

### Account Model
In the account model as used in Ethereum, the application state can be found by referencing a particular address.

As such, anyone would be able to view the activities of any account, simply with the knowledge of the address.

<p align="center" width="100%">
<img src={require("./images/ethereum_storage.png").default} alt="Ethereum Storage Diagram"></img>
</p>

<p align="center" width="100%">
Source: <a href="https://ethereum.org/en/develope.rs/docs/accounts/"> ethereum.org</a>
</p>
<br></br>


<p align="center" width="100%">
<img src={require("./images/ethereum_world_state.png").default} alt="Ethereum World State Diagram"></img>
</p>

<p align="center" width="100%">
Source: <a href="https://www.lucassaldanha.com/ethereum-yellow-paper-walkthrough-2/">Article by Lucas Saldanha</a>
</p>

<br></br>



### Record Model
In the record model, the application state, along with its owner are encrypted and stored on the blockchain.

<p align="center" width="300">
<img src={require("./images/record.png").default} alt="Aleo Records Diagram"></img>
</p>

<p align="center" width="100%">
Source: <a href="https://eprint.iacr.org/2018/962.pdf"> Zexe: Enabling Decentralized Private Computation</a>
</p>

<br></br>


<p align="center" width="100%">
<img src={require("./images/aleo_ledger.png").default} alt="Aleo World State Diagram"></img>
</p>


<p align="center" width="100%">
Source: <a href="https://eprint.iacr.org/2018/962.pdf"> Zexe: Enabling Decentralized Private Computation</a>
</p>
<br></br>



### Updating State
In the record model, applications update their state by consuming records containing the old state, and producing new records that contain the updated state. Records that have been used will be marked as spent and cannot be used again.

<p align="center" width="500">
<img src={require("./images/utxo.png").default} alt="UTXO diagram"></img>
</p>

<p align="center" width="100%">
Source: <a href="https://adapulse.io/the-extensive-guide-on-eutxo-utxo-and-the-accounts-based-model/"> adapulse.io</a>
</p>
<br></br>

The consumption and production of records is typically done in a transition function. A transaction in Aleo can contain up to 32 transitions, one of which is reserved for the transaction fee.


<p align="center" width="100%">
<img src={require("./images/transaction_in_aleo.png").default}  alt="Transaction in Aleo"></img>
</p>

### Why is the Record Model Useful?

In the account-based model, an application's data is stored in a persistent location tied to the application's account, and updates are made directly to this stored data. For a typical token transfer transaction using this model, user balances would be stored in a table mapping user account addresses to their respective balances. When User A transfers money to User B, A's balance in the table is reduced, and B's balance is increased by the same amount.
If we were to try making the transactions private (hiding the amount transferred and the identities of A and B), instead of storing actual balances, the application can store commitments to these balances. Transactions would then update these commitments rather than the actual balances. However, while this approach hides transaction values, it does not hide user identities. To also hide user identities, every transaction would need to update all commitments in the table, which becomes increasingly inefficient as the number of users grows.
Although the account model is more intuitive for developers, it uses account addresses to index global state. This means that while a private account model can achieve privacy for inputs and outputs, it still compromises user privacy since account addresses cannot be encrypted. Another issue with the private account model is the lack of concurrency, as only one user can access and update the entire program state at a time.
Aleo's record model uses program IDs to uniquely identify programs instead of account addresses. This improves privacy and enables programs to have internal states. This approach is more efficient and solves the concurrency issue.




 -->

<!-- 
## Transition Public Key (TPK)

The transition public key (`tpk`) is computed as part of the transition key generation process:

1. **Sample Random Nonce**: A random nonce is generated as a field element
2. **Compute Transition Secret Key (r)**: The transition secret key `r` is computed as:
   ```
   r = HashToScalar(serial_number_domain || sk_sig || nonce)
   ```
   Where `sk_sig` is the signature secret key from the account's private key and `||` denotes concatenation

3. **Compute Transition Public Key**: The `tpk` is computed as:
   ```
   tpk = r * G
   ```
   Where `G` is the generator point

The `tpk` is equivalent to `r * G` and serves as the random nonce used to verify the digital signature provided by the `owner` in a transaction.

## Transition View Key (TVK)

The transition view key (`tvk`) is computed after the transition public key generation:

**Compute Transition View Key**: The `tvk` is computed as:
```
tvk = (signer_address * r).to_x_coordinate()
```
Where the result is converted to its x-coordinate as a field element

The `tvk` is used in the encryption process for private inputs and outputs.

## Transition Commitment (TCM)

The transition commitment (`tcm`) is computed as:
```
tcm = Hash(tvk)
```
Where `tvk` is the transition view key computed in the previous step. This commitment provides a cryptographic binding to the transition view key while maintaining privacy.

## Signer Commitment (SCM)

The signer commitment (`scm`) is computed as:
```
scm = Hash(signer.to_x_coordinate() || root_tvk)
```
Where:
- `signer.to_x_coordinate()` is the x-coordinate of the signer's address
- `root_tvk` is the root transition view key when multiple circuits are involved
- The commitment binds the signer's identity to the root transition view key

The signer commitment serves as a cryptographic proof that links the transition to its creator while preserving privacy properties.

## Record

### Input Record
An `inputRecord` consists of a `record_commitment`, `gamma`, `record_view_key`, `serial_number`, and a `tag`. When a record is used as input to a transition, it is computed to its serial number through the following process:

1. **Record View Key Computation**: The record view key is computed as `(record.nonce * view_key).to_x_coordinate()`. `nonce` is computed from `randomizer * G` where `randomizer = Hash(tvk || index)`.

2. **Record Commitment**: There are currently two versions of record commitment:
   - **Version 0**: Hash of `(program_id || record_name || record)` without the last 8 version bits
   - **Version 1**: Take the Version 0 hash, append with version bits, then:
     - Construct commitment nonce: `Hash(commitment_domain || record_view_key)`
     - Compute the record `commitment` using the above nonce

:::note
Version 0 records from `credits.aleo` are required to upgrade by calling the `upgrade()` function.
:::

3. **Generator H Computation**: A generator `H` is computed as `HashToGroup(serial_number_domain || commitment)` using the Poseidon hash-to-group function with the serial number domain and commitment.

4. **Gamma Calculation**: `gamma` is calculated as `sk_sig * H`, where `sk_sig` is from the owner's private key, and `h_r` is computed as `r * H` for verification purposes.

5. **Serial Number Derivation**: The `serial_number` is computed by calling `Record::serial_number_from_gamma(gamma, commitment)`, which:
   - First calculates `sn_nonce` as `Hash(serial_number_domain || (COFACTOR * gamma).to_x_coordinate())`
   - Then computes `serial_number` as `Commit((serial_number_domain || commitment).to_bits_le(), sn_nonce)`

6. **Tag Calculation**: The `tag` is computed as `Record::tag(sk_tag, commitment)`, where `sk_tag` is derived from the graph key.

The serial number is disclosed on the ledger to publicly announce that the record has been spent, preventing double-spending while maintaining privacy. The tag is used to keep track of records that are spendable by the user.

### Output Record
An `outputRecord` consists of a `record_commitment`, `checksum`, `record_ciphertext`, and `sender_ciphertext`. When a record is produced as output from a transition, it is computed through the following process:

1. **Record Commitment**: There are currently two versions of record commitment:
   - **Version 0**: Hash of `(program_id || record_name || record)` without the last 8 version bits
   - **Version 1**: Take the Version 0 hash, append with version bits, then:
     - Construct commitment nonce: `Hash(commitment_domain || record_view_key)`
     - Compute the record `commitment` using the above nonce

2. **Record Encryption Randomizer**: The encryption randomizer for the record data is computed as `Hash(tvk || index)`, where `tvk` is the transition view key and `index` is the field element representation of the output register locator.

3. **Record View Key Generation**: The record view key is computed as `(owner_address * randomizer).to_x_coordinate()`, where `owner_address` is the record owner's address and `randomizer` is from step 2.

4. **Record Encryption**: The `record_ciphertext` is computed by:
   - Generating multiple randomizers using `Hash(encryption_domain || record_view_key)` based on the number of field elements needed
   - Encrypting each private field element by adding the corresponding randomizer: `encrypted_field[i] = plaintext_field[i] + randomizer[i]`
   - Constant and public entries remain unencrypted

5. **Checksum Calculation**: The `checksum` is computed as a hash of the `record_ciphertext` converted to little-endian bits and is used to verify the integrity of the encrypted record.

6. **Sender Ciphertext**: The `sender_ciphertext` is computed using a **different randomizer** distinct from the record encryption randomizer:
   - **Sender Ciphertext Randomizer**: Computed as `Hash(encryption_domain || record_view_key || 1)`
   - Encrypting the signer's address x-coordinate: `sender_ciphertext = signer_address.to_x_coordinate() + randomizer`

Record checksum and commitment are publicly visible on the ledger, while the record ciphertext contains the encrypted record data that can only be decrypted by the record owner. The sender ciphertext provides an encrypted reference to the transaction signer while maintaining privacy.

:::info
In the latest record version, commitments appear random even for similar records, making it difficult to associate them with specific data. The use of a view key ensures that only the record owner can correlate commitments with the actual data, offering enhanced privacy against traffic analysis and pattern matching.
:::

## Non-Record Ciphertext
Non-record ciphertext are encrypted data that hides private information on Aleo network and used to protect private inputs and outputs. Records can only be decrypted by the owner's view key, while non-record plaintext ciphertext can be decrypted using a plaintext view key derived from the function caller's view key.

### Encryption

#### 1: Create a Plaintext View Key
- The plaintext view key is computed as `Hash(function_id || tvk || index)`
- Where:
    - `function_id` is the unique identifier of the function being executed
    - `tvk` is the transition view key from the request
    - `index` is the field element representation of:
        - For inputs: the input index (cast from u16)
        - For outputs: `(num_inputs + output_index)`
- Each private input and output gets its own unique plaintext view key

#### 2: Generate Randomizers
- Determine the number of randomizers needed based on the plaintext structure
- Generate randomizers using `Hash(encryption_domain || plaintext_view_key)` with `num_randomizers` as number of outputs
- One randomizer is created for each field element in the plaintext

#### 3: Encrypt the Plaintext
- Convert the plaintext to field elements
- Add each randomizer to the corresponding field element:
  - `encrypted_field[i] = plaintext_field[i] + randomizer[i]`
- Create the ciphertext from the encrypted field elements

#### 4: Compute Ciphertext Hash
- Convert the ciphertext to field elements
- Compute the ciphertext hash as `Hash(ciphertext_fields)`
- This hash serves as the output ID for verification

### Decryption

#### 1: Recreate the Plaintext View Key
- Use the same method as encryption
- Compute `plaintext_view_key = (tpk * view_key).to_x_coordinate()`
- Where `tpk` is the transition public key (`r * G`) and `view_key` is the account view key
- This works because the signer address is basically a scalar multiplication of `view_key` on generator `G`

#### 2: Regenerate the Same Randomizers
- Determine the number of randomizers needed (same as encryption)
- Use the same hash function: `Hash(encryption_domain || plaintext_view_key)` with `num_randomizers` as number of outputs

#### 3: Decrypt the Ciphertext
- Subtract each randomizer from the corresponding encrypted field element:
  - `plaintext_field[i] = encrypted_field[i] - randomizer[i]`
- Reconstruct the original plaintext from the decrypted field elements -->





## Determining Transaction Status

Transactions processed by Aleo validators achieve one of the following states:

| Status | Description |
|:------:|:------------|
| `accepted` | The underlying deployment or execution was successful, and the associated fee was consumed. The transaction has a confirmed ID. |
| `rejected` | The deployment or execution logic failed. Validators process the fee as an independent fee transaction. The original transaction has an unconfirmed ID, while the fee transaction has a confirmed ID. |
| `aborted` | Both the deployment/execution logic and fee processing failed. The transaction is aborted. |

:::note
Transactions may not be included in any block when not selected from the mempool by validators during high network load conditions.
:::

### Method 1: Parsing Transactions from Blocks

Transaction status can be determined by processing blocks retrieved via:  

- `GET /<network>/block/{height}` - snarkOS node endpoint
- [Get block by height or hash](https://docs.explorer.provable.com/docs/api-reference/8sqnes7uvwe05-get-block-by-height-or-hash) on the Provable explorer

Transaction status can be determined from a block response as follows:

#### Accepted Transactions
- Get the list of transactions using `echo response | jq .transactions`
- The transaction JSON contains `"status": "accepted"`
- The transaction id is present in `echo transaction | jq .transaction.id`

#### Rejected Transactions
- Get the list of transactions using `echo response | jq .transactions`
- The transaction JSON contains `"status": "rejected"`
- The confirmed transaction id is present in `echo transaction | jq .transaction.id`
- The associated unconfirmed transaction id can be acquired by:
  - Calling `GET /<network>/unconfirmed/{confirmed id}` and calling `echo transaction | jq .transaction.id`
  - You can also hit `https://api.explorer.provable.com/v1/mainnet/transaction/unconfirmed/{ID}`

#### Aborted Transactions
- Get the list of aborted ids using `echo response | jq .aborted_transaction_ids`

#### SDK - getConfirmedTransaction

```javascript
import { AleoNetworkClient } from '@provablehq/sdk/mainnet.js';

const net  = new AleoNetworkClient('https://api.explorer.provable.com/v1');   
const txId = 'at14v8nt94d7xmsp3dq2glpzft6xw3x42ne753mlt8uenn8zw76dsqqc65jnf';                                

const status = await net.getConfirmedTransaction(txId);
console.log(status.status);
```

### Method 2: Directly Querying Transaction Status

An alternative way to get feedback on the status of transactions, is to call the following endpoint.

- `GET /<network>/transaction/confirmed/{transaction id}` on a fully synced snarkOS node REST endpoint
- [Get transaction by ID](https://docs.explorer.provable.com/docs/api-reference/bqly6ukna97b6-get-transaction-by-id) on the Provable explorer

If the transaction was accepted, `echo $transaction | jq .type` will say "execute"  
If the transaction was rejected, `echo $transaction | jq .type` will say "fee"
:::note
Currently no API endpoint is available to quickly check whether a transaction was aborted.
:::

Given a confirmed transaction id, you can find the block it was included in using:

- `GET /<network>/find/blockHash//{transaction id}` on a fully synced snarkOS node REST endpoint
- [Get block hash for transaction ID](https://docs.explorer.provable.com/docs/api-reference/8ka85a1oq8iau-get-block-hash-for-transaction-id) on the Provable explorer

#### SDK - fetchData and getBlockByHash

```javascript
import { AleoNetworkClient } from '@provablehq/sdk/mainnet.js';

const net  = new AleoNetworkClient('https://api.explorer.provable.com/v1');   
const txId = 'at14v8nt94d7xmsp3dq2glpzft6xw3x42ne753mlt8uenn8zw76dsqqc65jnf'; 
// Get block hash using fetchData
const res = await net.fetchData('/find/blockHash/' + txId);   
// Get block by using getBlockByHash 
const block = await net.getBlockByHash(res)
// Get block height by response json
console.log(block.header.metadata.height);
```

### Parsing the Sender Address from transfer_public or transfer_public_as_signer Executions

Note that the sender address might be an externally owned account (EOA), i.e. owned by a user, or it might be the address of an Aleo program.

The sender address of a Transaction is present as the first argument of the first output. The following will return a human readable string containing the public values of the first output.

```bash
echo $transaction | jq '.execution.transitions[0].outputs[0].value'
```

Unfortunately, the current snarkOS and explorer REST endpoints return execution outputs as a string which is not compatible with JSON. You'll still need to extract the first value from it. The sender address can be parsed for example using a regex or by parsing out the 5th line:

```bash
echo $(echo $transaction | jq '.execution.transitions[0].outputs[0].value') | sed -n '5p'
```

### Summarized Block Contents

A block contains confirmed transactions.

A confirmed transaction can either have status "accepted" or "rejected", and type "deploy" or "execute", and it contains a "transaction" and optional "rejected" object.

- A "transaction" can have type "fee", "execute" or "deploy".
- A "rejected" can have type "execution" or "deployment".

```json
{
  …,
  "transactions": [
    "status": "accepted"/"rejected"
    "type": "deploy"/"execute",
    "transaction": {
      …,
      "type": "fee"/"execute"/"deploy"
    }
 "rejected": {
      …,
      "type": "execution"/"deployment"
    } 
  ],
  "unconfirmed_transaction_ids": [...]
}
```
